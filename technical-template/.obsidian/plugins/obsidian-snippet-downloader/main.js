/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// node_modules/before-after-hook/lib/register.js
var require_register = __commonJS({
  "node_modules/before-after-hook/lib/register.js"(exports, module2) {
    module2.exports = register;
    function register(state, name, method, options) {
      if (typeof method !== "function") {
        throw new Error("method for before hook must be a function");
      }
      if (!options) {
        options = {};
      }
      if (Array.isArray(name)) {
        return name.reverse().reduce(function(callback, name2) {
          return register.bind(null, state, name2, callback, options);
        }, method)();
      }
      return Promise.resolve().then(function() {
        if (!state.registry[name]) {
          return method(options);
        }
        return state.registry[name].reduce(function(method2, registered) {
          return registered.hook.bind(null, method2, options);
        }, method)();
      });
    }
  }
});

// node_modules/before-after-hook/lib/add.js
var require_add = __commonJS({
  "node_modules/before-after-hook/lib/add.js"(exports, module2) {
    module2.exports = addHook;
    function addHook(state, kind, name, hook2) {
      var orig = hook2;
      if (!state.registry[name]) {
        state.registry[name] = [];
      }
      if (kind === "before") {
        hook2 = function(method, options) {
          return Promise.resolve().then(orig.bind(null, options)).then(method.bind(null, options));
        };
      }
      if (kind === "after") {
        hook2 = function(method, options) {
          var result;
          return Promise.resolve().then(method.bind(null, options)).then(function(result_) {
            result = result_;
            return orig(result, options);
          }).then(function() {
            return result;
          });
        };
      }
      if (kind === "error") {
        hook2 = function(method, options) {
          return Promise.resolve().then(method.bind(null, options)).catch(function(error) {
            return orig(error, options);
          });
        };
      }
      state.registry[name].push({
        hook: hook2,
        orig
      });
    }
  }
});

// node_modules/before-after-hook/lib/remove.js
var require_remove = __commonJS({
  "node_modules/before-after-hook/lib/remove.js"(exports, module2) {
    module2.exports = removeHook;
    function removeHook(state, name, method) {
      if (!state.registry[name]) {
        return;
      }
      var index = state.registry[name].map(function(registered) {
        return registered.orig;
      }).indexOf(method);
      if (index === -1) {
        return;
      }
      state.registry[name].splice(index, 1);
    }
  }
});

// node_modules/before-after-hook/index.js
var require_before_after_hook = __commonJS({
  "node_modules/before-after-hook/index.js"(exports, module2) {
    var register = require_register();
    var addHook = require_add();
    var removeHook = require_remove();
    var bind = Function.bind;
    var bindable = bind.bind(bind);
    function bindApi(hook2, state, name) {
      var removeHookRef = bindable(removeHook, null).apply(null, name ? [state, name] : [state]);
      hook2.api = { remove: removeHookRef };
      hook2.remove = removeHookRef;
      ["before", "error", "after", "wrap"].forEach(function(kind) {
        var args = name ? [state, kind, name] : [state, kind];
        hook2[kind] = hook2.api[kind] = bindable(addHook, null).apply(null, args);
      });
    }
    function HookSingular() {
      var singularHookName = "h";
      var singularHookState = {
        registry: {}
      };
      var singularHook = register.bind(null, singularHookState, singularHookName);
      bindApi(singularHook, singularHookState, singularHookName);
      return singularHook;
    }
    function HookCollection() {
      var state = {
        registry: {}
      };
      var hook2 = register.bind(null, state);
      bindApi(hook2, state);
      return hook2;
    }
    var collectionHookDeprecationMessageDisplayed = false;
    function Hook() {
      if (!collectionHookDeprecationMessageDisplayed) {
        console.warn('[before-after-hook]: "Hook()" repurposing warning, use "Hook.Collection()". Read more: https://git.io/upgrade-before-after-hook-to-1.4');
        collectionHookDeprecationMessageDisplayed = true;
      }
      return HookCollection();
    }
    Hook.Singular = HookSingular.bind();
    Hook.Collection = HookCollection.bind();
    module2.exports = Hook;
    module2.exports.Hook = Hook;
    module2.exports.Singular = Hook.Singular;
    module2.exports.Collection = Hook.Collection;
  }
});

// node_modules/node-fetch/browser.js
var require_browser = __commonJS({
  "node_modules/node-fetch/browser.js"(exports, module2) {
    "use strict";
    var getGlobal = function() {
      if (typeof self !== "undefined") {
        return self;
      }
      if (typeof window !== "undefined") {
        return window;
      }
      if (typeof global !== "undefined") {
        return global;
      }
      throw new Error("unable to locate global object");
    };
    var global = getGlobal();
    module2.exports = exports = global.fetch;
    if (global.fetch) {
      exports.default = global.fetch.bind(global);
    }
    exports.Headers = global.Headers;
    exports.Request = global.Request;
    exports.Response = global.Response;
  }
});

// node_modules/wrappy/wrappy.js
var require_wrappy = __commonJS({
  "node_modules/wrappy/wrappy.js"(exports, module2) {
    module2.exports = wrappy;
    function wrappy(fn, cb) {
      if (fn && cb)
        return wrappy(fn)(cb);
      if (typeof fn !== "function")
        throw new TypeError("need wrapper function");
      Object.keys(fn).forEach(function(k) {
        wrapper[k] = fn[k];
      });
      return wrapper;
      function wrapper() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        var ret = fn.apply(this, args);
        var cb2 = args[args.length - 1];
        if (typeof ret === "function" && ret !== cb2) {
          Object.keys(cb2).forEach(function(k) {
            ret[k] = cb2[k];
          });
        }
        return ret;
      }
    }
  }
});

// node_modules/once/once.js
var require_once = __commonJS({
  "node_modules/once/once.js"(exports, module2) {
    var wrappy = require_wrappy();
    module2.exports = wrappy(once2);
    module2.exports.strict = wrappy(onceStrict);
    once2.proto = once2(function() {
      Object.defineProperty(Function.prototype, "once", {
        value: function() {
          return once2(this);
        },
        configurable: true
      });
      Object.defineProperty(Function.prototype, "onceStrict", {
        value: function() {
          return onceStrict(this);
        },
        configurable: true
      });
    });
    function once2(fn) {
      var f = function() {
        if (f.called)
          return f.value;
        f.called = true;
        return f.value = fn.apply(this, arguments);
      };
      f.called = false;
      return f;
    }
    function onceStrict(fn) {
      var f = function() {
        if (f.called)
          throw new Error(f.onceError);
        f.called = true;
        return f.value = fn.apply(this, arguments);
      };
      var name = fn.name || "Function wrapped with `once`";
      f.onceError = name + " shouldn't be called more than once";
      f.called = false;
      return f;
    }
  }
});

// Snippet-downloader/main.ts
__export(exports, {
  default: () => snippetDownloader
});
var import_obsidian8 = __toModule(require("obsidian"));

// Snippet-downloader/settings.ts
var import_obsidian7 = __toModule(require("obsidian"));

// Snippet-downloader/removeSnippet.ts
var import_obsidian = __toModule(require("obsidian"));

// Snippet-downloader/utils.ts
function searchExcluded(excludedSnippet, name) {
  if (excludedSnippet.length < 1) {
    return false;
  }
  const excluded = excludedSnippet.split(",").map((e) => {
    return e.trim();
  }).filter((x) => x.length > 0);
  for (const excl of excluded) {
    if (excl === name.replace(".css", "").trim()) {
      return true;
    }
    if (name.match(new RegExp(excl))) {
      return true;
    }
  }
  return false;
}
function basename(path) {
  return path.split("/").reverse()[0];
}

// Snippet-downloader/removeSnippet.ts
function removeErrorSnippet(repoPath, errorSnippet, snippetList) {
  const snippet = snippetList.find((snippet2) => snippet2.repo === repoPath);
  let errorSnippetList = errorSnippet.split(", ");
  for (const snippetContents of snippet.snippetsContents) {
    errorSnippetList = errorSnippetList.filter((v) => v != snippetContents.name.replace(".css", "").trim());
  }
  console.log(errorSnippetList);
  return errorSnippetList.join(", ");
}
function removeSnippet(repoPath, snippetList, errorSnippet) {
  if (snippetList.some((snippet) => snippet.repo === repoPath)) {
    errorSnippet = removeErrorSnippet(repoPath, errorSnippet, snippetList);
    snippetList.splice(snippetList.findIndex((snippet) => snippet.repo === repoPath), 1);
    new import_obsidian.Notice("Repository successfully removed \u{1F389}");
    return [snippetList, errorSnippet];
  }
  new import_obsidian.Notice("Error : this repo is not in the list \u{1F63F}");
  return [snippetList, errorSnippet];
}
function removeSnippetFromExcluded(repoPath, snippetList, errorSnippet, excludedSnippet) {
  const repo = snippetList.find((snippet) => snippet.repo === repoPath);
  repo.snippetsContents = repo.snippetsContents.filter((snippet) => !searchExcluded(excludedSnippet, snippet.name) && !searchExcluded(errorSnippet, snippet.name));
  return snippetList;
}

// Snippet-downloader/modals/simpleCommands.ts
var import_obsidian2 = __toModule(require("obsidian"));
var SnippetDownloaderModals = class extends import_obsidian2.Modal {
  constructor(app, onSubmit) {
    super(app);
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h1", { text: "Repo Links" });
    new import_obsidian2.Setting(contentEl).setName("Repo Link").addText((text) => {
      text.onChange((value) => {
        this.result = value;
      });
    });
    new import_obsidian2.Setting(contentEl).addButton((btn) => {
      btn.setButtonText("Submit").setCta().onClick(() => {
        this.close();
        this.onSubmit(this.result);
      });
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// Snippet-downloader/addSnippets.ts
var import_obsidian4 = __toModule(require("obsidian"));

// node_modules/universal-user-agent/dist-web/index.js
function getUserAgent() {
  if (typeof navigator === "object" && "userAgent" in navigator) {
    return navigator.userAgent;
  }
  if (typeof process === "object" && "version" in process) {
    return `Node.js/${process.version.substr(1)} (${process.platform}; ${process.arch})`;
  }
  return "<environment undetectable>";
}

// node_modules/@octokit/core/dist-web/index.js
var import_before_after_hook = __toModule(require_before_after_hook());

// node_modules/is-plain-object/dist/is-plain-object.mjs
function isObject(o) {
  return Object.prototype.toString.call(o) === "[object Object]";
}
function isPlainObject(o) {
  var ctor, prot;
  if (isObject(o) === false)
    return false;
  ctor = o.constructor;
  if (ctor === void 0)
    return true;
  prot = ctor.prototype;
  if (isObject(prot) === false)
    return false;
  if (prot.hasOwnProperty("isPrototypeOf") === false) {
    return false;
  }
  return true;
}

// node_modules/@octokit/endpoint/dist-web/index.js
function lowercaseKeys(object) {
  if (!object) {
    return {};
  }
  return Object.keys(object).reduce((newObj, key) => {
    newObj[key.toLowerCase()] = object[key];
    return newObj;
  }, {});
}
function mergeDeep(defaults, options) {
  const result = Object.assign({}, defaults);
  Object.keys(options).forEach((key) => {
    if (isPlainObject(options[key])) {
      if (!(key in defaults))
        Object.assign(result, { [key]: options[key] });
      else
        result[key] = mergeDeep(defaults[key], options[key]);
    } else {
      Object.assign(result, { [key]: options[key] });
    }
  });
  return result;
}
function removeUndefinedProperties(obj) {
  for (const key in obj) {
    if (obj[key] === void 0) {
      delete obj[key];
    }
  }
  return obj;
}
function merge(defaults, route, options) {
  if (typeof route === "string") {
    let [method, url] = route.split(" ");
    options = Object.assign(url ? { method, url } : { url: method }, options);
  } else {
    options = Object.assign({}, route);
  }
  options.headers = lowercaseKeys(options.headers);
  removeUndefinedProperties(options);
  removeUndefinedProperties(options.headers);
  const mergedOptions = mergeDeep(defaults || {}, options);
  if (defaults && defaults.mediaType.previews.length) {
    mergedOptions.mediaType.previews = defaults.mediaType.previews.filter((preview) => !mergedOptions.mediaType.previews.includes(preview)).concat(mergedOptions.mediaType.previews);
  }
  mergedOptions.mediaType.previews = mergedOptions.mediaType.previews.map((preview) => preview.replace(/-preview/, ""));
  return mergedOptions;
}
function addQueryParameters(url, parameters) {
  const separator = /\?/.test(url) ? "&" : "?";
  const names = Object.keys(parameters);
  if (names.length === 0) {
    return url;
  }
  return url + separator + names.map((name) => {
    if (name === "q") {
      return "q=" + parameters.q.split("+").map(encodeURIComponent).join("+");
    }
    return `${name}=${encodeURIComponent(parameters[name])}`;
  }).join("&");
}
var urlVariableRegex = /\{[^}]+\}/g;
function removeNonChars(variableName) {
  return variableName.replace(/^\W+|\W+$/g, "").split(/,/);
}
function extractUrlVariableNames(url) {
  const matches = url.match(urlVariableRegex);
  if (!matches) {
    return [];
  }
  return matches.map(removeNonChars).reduce((a, b) => a.concat(b), []);
}
function omit(object, keysToOmit) {
  return Object.keys(object).filter((option) => !keysToOmit.includes(option)).reduce((obj, key) => {
    obj[key] = object[key];
    return obj;
  }, {});
}
function encodeReserved(str) {
  return str.split(/(%[0-9A-Fa-f]{2})/g).map(function(part) {
    if (!/%[0-9A-Fa-f]/.test(part)) {
      part = encodeURI(part).replace(/%5B/g, "[").replace(/%5D/g, "]");
    }
    return part;
  }).join("");
}
function encodeUnreserved(str) {
  return encodeURIComponent(str).replace(/[!'()*]/g, function(c) {
    return "%" + c.charCodeAt(0).toString(16).toUpperCase();
  });
}
function encodeValue(operator, value, key) {
  value = operator === "+" || operator === "#" ? encodeReserved(value) : encodeUnreserved(value);
  if (key) {
    return encodeUnreserved(key) + "=" + value;
  } else {
    return value;
  }
}
function isDefined(value) {
  return value !== void 0 && value !== null;
}
function isKeyOperator(operator) {
  return operator === ";" || operator === "&" || operator === "?";
}
function getValues(context, operator, key, modifier) {
  var value = context[key], result = [];
  if (isDefined(value) && value !== "") {
    if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
      value = value.toString();
      if (modifier && modifier !== "*") {
        value = value.substring(0, parseInt(modifier, 10));
      }
      result.push(encodeValue(operator, value, isKeyOperator(operator) ? key : ""));
    } else {
      if (modifier === "*") {
        if (Array.isArray(value)) {
          value.filter(isDefined).forEach(function(value2) {
            result.push(encodeValue(operator, value2, isKeyOperator(operator) ? key : ""));
          });
        } else {
          Object.keys(value).forEach(function(k) {
            if (isDefined(value[k])) {
              result.push(encodeValue(operator, value[k], k));
            }
          });
        }
      } else {
        const tmp = [];
        if (Array.isArray(value)) {
          value.filter(isDefined).forEach(function(value2) {
            tmp.push(encodeValue(operator, value2));
          });
        } else {
          Object.keys(value).forEach(function(k) {
            if (isDefined(value[k])) {
              tmp.push(encodeUnreserved(k));
              tmp.push(encodeValue(operator, value[k].toString()));
            }
          });
        }
        if (isKeyOperator(operator)) {
          result.push(encodeUnreserved(key) + "=" + tmp.join(","));
        } else if (tmp.length !== 0) {
          result.push(tmp.join(","));
        }
      }
    }
  } else {
    if (operator === ";") {
      if (isDefined(value)) {
        result.push(encodeUnreserved(key));
      }
    } else if (value === "" && (operator === "&" || operator === "?")) {
      result.push(encodeUnreserved(key) + "=");
    } else if (value === "") {
      result.push("");
    }
  }
  return result;
}
function parseUrl(template) {
  return {
    expand: expand.bind(null, template)
  };
}
function expand(template, context) {
  var operators = ["+", "#", ".", "/", ";", "?", "&"];
  return template.replace(/\{([^\{\}]+)\}|([^\{\}]+)/g, function(_, expression, literal) {
    if (expression) {
      let operator = "";
      const values = [];
      if (operators.indexOf(expression.charAt(0)) !== -1) {
        operator = expression.charAt(0);
        expression = expression.substr(1);
      }
      expression.split(/,/g).forEach(function(variable) {
        var tmp = /([^:\*]*)(?::(\d+)|(\*))?/.exec(variable);
        values.push(getValues(context, operator, tmp[1], tmp[2] || tmp[3]));
      });
      if (operator && operator !== "+") {
        var separator = ",";
        if (operator === "?") {
          separator = "&";
        } else if (operator !== "#") {
          separator = operator;
        }
        return (values.length !== 0 ? operator : "") + values.join(separator);
      } else {
        return values.join(",");
      }
    } else {
      return encodeReserved(literal);
    }
  });
}
function parse(options) {
  let method = options.method.toUpperCase();
  let url = (options.url || "/").replace(/:([a-z]\w+)/g, "{$1}");
  let headers = Object.assign({}, options.headers);
  let body;
  let parameters = omit(options, [
    "method",
    "baseUrl",
    "url",
    "headers",
    "request",
    "mediaType"
  ]);
  const urlVariableNames = extractUrlVariableNames(url);
  url = parseUrl(url).expand(parameters);
  if (!/^http/.test(url)) {
    url = options.baseUrl + url;
  }
  const omittedParameters = Object.keys(options).filter((option) => urlVariableNames.includes(option)).concat("baseUrl");
  const remainingParameters = omit(parameters, omittedParameters);
  const isBinaryRequest = /application\/octet-stream/i.test(headers.accept);
  if (!isBinaryRequest) {
    if (options.mediaType.format) {
      headers.accept = headers.accept.split(/,/).map((preview) => preview.replace(/application\/vnd(\.\w+)(\.v3)?(\.\w+)?(\+json)?$/, `application/vnd$1$2.${options.mediaType.format}`)).join(",");
    }
    if (options.mediaType.previews.length) {
      const previewsFromAcceptHeader = headers.accept.match(/[\w-]+(?=-preview)/g) || [];
      headers.accept = previewsFromAcceptHeader.concat(options.mediaType.previews).map((preview) => {
        const format = options.mediaType.format ? `.${options.mediaType.format}` : "+json";
        return `application/vnd.github.${preview}-preview${format}`;
      }).join(",");
    }
  }
  if (["GET", "HEAD"].includes(method)) {
    url = addQueryParameters(url, remainingParameters);
  } else {
    if ("data" in remainingParameters) {
      body = remainingParameters.data;
    } else {
      if (Object.keys(remainingParameters).length) {
        body = remainingParameters;
      } else {
        headers["content-length"] = 0;
      }
    }
  }
  if (!headers["content-type"] && typeof body !== "undefined") {
    headers["content-type"] = "application/json; charset=utf-8";
  }
  if (["PATCH", "PUT"].includes(method) && typeof body === "undefined") {
    body = "";
  }
  return Object.assign({ method, url, headers }, typeof body !== "undefined" ? { body } : null, options.request ? { request: options.request } : null);
}
function endpointWithDefaults(defaults, route, options) {
  return parse(merge(defaults, route, options));
}
function withDefaults(oldDefaults, newDefaults) {
  const DEFAULTS2 = merge(oldDefaults, newDefaults);
  const endpoint2 = endpointWithDefaults.bind(null, DEFAULTS2);
  return Object.assign(endpoint2, {
    DEFAULTS: DEFAULTS2,
    defaults: withDefaults.bind(null, DEFAULTS2),
    merge: merge.bind(null, DEFAULTS2),
    parse
  });
}
var VERSION = "6.0.12";
var userAgent = `octokit-endpoint.js/${VERSION} ${getUserAgent()}`;
var DEFAULTS = {
  method: "GET",
  baseUrl: "https://api.github.com",
  headers: {
    accept: "application/vnd.github.v3+json",
    "user-agent": userAgent
  },
  mediaType: {
    format: "",
    previews: []
  }
};
var endpoint = withDefaults(null, DEFAULTS);

// node_modules/@octokit/request/dist-web/index.js
var import_node_fetch = __toModule(require_browser());

// node_modules/deprecation/dist-web/index.js
var Deprecation = class extends Error {
  constructor(message) {
    super(message);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
    this.name = "Deprecation";
  }
};

// node_modules/@octokit/request-error/dist-web/index.js
var import_once = __toModule(require_once());
var logOnceCode = (0, import_once.default)((deprecation) => console.warn(deprecation));
var logOnceHeaders = (0, import_once.default)((deprecation) => console.warn(deprecation));
var RequestError = class extends Error {
  constructor(message, statusCode, options) {
    super(message);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
    this.name = "HttpError";
    this.status = statusCode;
    let headers;
    if ("headers" in options && typeof options.headers !== "undefined") {
      headers = options.headers;
    }
    if ("response" in options) {
      this.response = options.response;
      headers = options.response.headers;
    }
    const requestCopy = Object.assign({}, options.request);
    if (options.request.headers.authorization) {
      requestCopy.headers = Object.assign({}, options.request.headers, {
        authorization: options.request.headers.authorization.replace(/ .*$/, " [REDACTED]")
      });
    }
    requestCopy.url = requestCopy.url.replace(/\bclient_secret=\w+/g, "client_secret=[REDACTED]").replace(/\baccess_token=\w+/g, "access_token=[REDACTED]");
    this.request = requestCopy;
    Object.defineProperty(this, "code", {
      get() {
        logOnceCode(new Deprecation("[@octokit/request-error] `error.code` is deprecated, use `error.status`."));
        return statusCode;
      }
    });
    Object.defineProperty(this, "headers", {
      get() {
        logOnceHeaders(new Deprecation("[@octokit/request-error] `error.headers` is deprecated, use `error.response.headers`."));
        return headers || {};
      }
    });
  }
};

// node_modules/@octokit/request/dist-web/index.js
var VERSION2 = "5.6.3";
function getBufferResponse(response) {
  return response.arrayBuffer();
}
function fetchWrapper(requestOptions) {
  const log = requestOptions.request && requestOptions.request.log ? requestOptions.request.log : console;
  if (isPlainObject(requestOptions.body) || Array.isArray(requestOptions.body)) {
    requestOptions.body = JSON.stringify(requestOptions.body);
  }
  let headers = {};
  let status;
  let url;
  const fetch = requestOptions.request && requestOptions.request.fetch || import_node_fetch.default;
  return fetch(requestOptions.url, Object.assign({
    method: requestOptions.method,
    body: requestOptions.body,
    headers: requestOptions.headers,
    redirect: requestOptions.redirect
  }, requestOptions.request)).then((response) => __async(this, null, function* () {
    url = response.url;
    status = response.status;
    for (const keyAndValue of response.headers) {
      headers[keyAndValue[0]] = keyAndValue[1];
    }
    if ("deprecation" in headers) {
      const matches = headers.link && headers.link.match(/<([^>]+)>; rel="deprecation"/);
      const deprecationLink = matches && matches.pop();
      log.warn(`[@octokit/request] "${requestOptions.method} ${requestOptions.url}" is deprecated. It is scheduled to be removed on ${headers.sunset}${deprecationLink ? `. See ${deprecationLink}` : ""}`);
    }
    if (status === 204 || status === 205) {
      return;
    }
    if (requestOptions.method === "HEAD") {
      if (status < 400) {
        return;
      }
      throw new RequestError(response.statusText, status, {
        response: {
          url,
          status,
          headers,
          data: void 0
        },
        request: requestOptions
      });
    }
    if (status === 304) {
      throw new RequestError("Not modified", status, {
        response: {
          url,
          status,
          headers,
          data: yield getResponseData(response)
        },
        request: requestOptions
      });
    }
    if (status >= 400) {
      const data = yield getResponseData(response);
      const error = new RequestError(toErrorMessage(data), status, {
        response: {
          url,
          status,
          headers,
          data
        },
        request: requestOptions
      });
      throw error;
    }
    return getResponseData(response);
  })).then((data) => {
    return {
      status,
      url,
      headers,
      data
    };
  }).catch((error) => {
    if (error instanceof RequestError)
      throw error;
    throw new RequestError(error.message, 500, {
      request: requestOptions
    });
  });
}
function getResponseData(response) {
  return __async(this, null, function* () {
    const contentType = response.headers.get("content-type");
    if (/application\/json/.test(contentType)) {
      return response.json();
    }
    if (!contentType || /^text\/|charset=utf-8$/.test(contentType)) {
      return response.text();
    }
    return getBufferResponse(response);
  });
}
function toErrorMessage(data) {
  if (typeof data === "string")
    return data;
  if ("message" in data) {
    if (Array.isArray(data.errors)) {
      return `${data.message}: ${data.errors.map(JSON.stringify).join(", ")}`;
    }
    return data.message;
  }
  return `Unknown error: ${JSON.stringify(data)}`;
}
function withDefaults2(oldEndpoint, newDefaults) {
  const endpoint2 = oldEndpoint.defaults(newDefaults);
  const newApi = function(route, parameters) {
    const endpointOptions = endpoint2.merge(route, parameters);
    if (!endpointOptions.request || !endpointOptions.request.hook) {
      return fetchWrapper(endpoint2.parse(endpointOptions));
    }
    const request3 = (route2, parameters2) => {
      return fetchWrapper(endpoint2.parse(endpoint2.merge(route2, parameters2)));
    };
    Object.assign(request3, {
      endpoint: endpoint2,
      defaults: withDefaults2.bind(null, endpoint2)
    });
    return endpointOptions.request.hook(request3, endpointOptions);
  };
  return Object.assign(newApi, {
    endpoint: endpoint2,
    defaults: withDefaults2.bind(null, endpoint2)
  });
}
var request = withDefaults2(endpoint, {
  headers: {
    "user-agent": `octokit-request.js/${VERSION2} ${getUserAgent()}`
  }
});

// node_modules/@octokit/graphql/dist-web/index.js
var VERSION3 = "4.8.0";
function _buildMessageForResponseErrors(data) {
  return `Request failed due to following response errors:
` + data.errors.map((e) => ` - ${e.message}`).join("\n");
}
var GraphqlResponseError = class extends Error {
  constructor(request3, headers, response) {
    super(_buildMessageForResponseErrors(response));
    this.request = request3;
    this.headers = headers;
    this.response = response;
    this.name = "GraphqlResponseError";
    this.errors = response.errors;
    this.data = response.data;
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
  }
};
var NON_VARIABLE_OPTIONS = [
  "method",
  "baseUrl",
  "url",
  "headers",
  "request",
  "query",
  "mediaType"
];
var FORBIDDEN_VARIABLE_OPTIONS = ["query", "method", "url"];
var GHES_V3_SUFFIX_REGEX = /\/api\/v3\/?$/;
function graphql(request3, query, options) {
  if (options) {
    if (typeof query === "string" && "query" in options) {
      return Promise.reject(new Error(`[@octokit/graphql] "query" cannot be used as variable name`));
    }
    for (const key in options) {
      if (!FORBIDDEN_VARIABLE_OPTIONS.includes(key))
        continue;
      return Promise.reject(new Error(`[@octokit/graphql] "${key}" cannot be used as variable name`));
    }
  }
  const parsedOptions = typeof query === "string" ? Object.assign({ query }, options) : query;
  const requestOptions = Object.keys(parsedOptions).reduce((result, key) => {
    if (NON_VARIABLE_OPTIONS.includes(key)) {
      result[key] = parsedOptions[key];
      return result;
    }
    if (!result.variables) {
      result.variables = {};
    }
    result.variables[key] = parsedOptions[key];
    return result;
  }, {});
  const baseUrl = parsedOptions.baseUrl || request3.endpoint.DEFAULTS.baseUrl;
  if (GHES_V3_SUFFIX_REGEX.test(baseUrl)) {
    requestOptions.url = baseUrl.replace(GHES_V3_SUFFIX_REGEX, "/api/graphql");
  }
  return request3(requestOptions).then((response) => {
    if (response.data.errors) {
      const headers = {};
      for (const key of Object.keys(response.headers)) {
        headers[key] = response.headers[key];
      }
      throw new GraphqlResponseError(requestOptions, headers, response.data);
    }
    return response.data.data;
  });
}
function withDefaults3(request$1, newDefaults) {
  const newRequest = request$1.defaults(newDefaults);
  const newApi = (query, options) => {
    return graphql(newRequest, query, options);
  };
  return Object.assign(newApi, {
    defaults: withDefaults3.bind(null, newRequest),
    endpoint: request.endpoint
  });
}
var graphql$1 = withDefaults3(request, {
  headers: {
    "user-agent": `octokit-graphql.js/${VERSION3} ${getUserAgent()}`
  },
  method: "POST",
  url: "/graphql"
});
function withCustomRequest(customRequest) {
  return withDefaults3(customRequest, {
    method: "POST",
    url: "/graphql"
  });
}

// node_modules/@octokit/auth-token/dist-web/index.js
var REGEX_IS_INSTALLATION_LEGACY = /^v1\./;
var REGEX_IS_INSTALLATION = /^ghs_/;
var REGEX_IS_USER_TO_SERVER = /^ghu_/;
function auth(token) {
  return __async(this, null, function* () {
    const isApp = token.split(/\./).length === 3;
    const isInstallation = REGEX_IS_INSTALLATION_LEGACY.test(token) || REGEX_IS_INSTALLATION.test(token);
    const isUserToServer = REGEX_IS_USER_TO_SERVER.test(token);
    const tokenType = isApp ? "app" : isInstallation ? "installation" : isUserToServer ? "user-to-server" : "oauth";
    return {
      type: "token",
      token,
      tokenType
    };
  });
}
function withAuthorizationPrefix(token) {
  if (token.split(/\./).length === 3) {
    return `bearer ${token}`;
  }
  return `token ${token}`;
}
function hook(token, request3, route, parameters) {
  return __async(this, null, function* () {
    const endpoint2 = request3.endpoint.merge(route, parameters);
    endpoint2.headers.authorization = withAuthorizationPrefix(token);
    return request3(endpoint2);
  });
}
var createTokenAuth = function createTokenAuth2(token) {
  if (!token) {
    throw new Error("[@octokit/auth-token] No token passed to createTokenAuth");
  }
  if (typeof token !== "string") {
    throw new Error("[@octokit/auth-token] Token passed to createTokenAuth is not a string");
  }
  token = token.replace(/^(token|bearer) +/i, "");
  return Object.assign(auth.bind(null, token), {
    hook: hook.bind(null, token)
  });
};

// node_modules/@octokit/core/dist-web/index.js
var VERSION4 = "3.6.0";
var Octokit = class {
  constructor(options = {}) {
    const hook2 = new import_before_after_hook.Collection();
    const requestDefaults = {
      baseUrl: request.endpoint.DEFAULTS.baseUrl,
      headers: {},
      request: Object.assign({}, options.request, {
        hook: hook2.bind(null, "request")
      }),
      mediaType: {
        previews: [],
        format: ""
      }
    };
    requestDefaults.headers["user-agent"] = [
      options.userAgent,
      `octokit-core.js/${VERSION4} ${getUserAgent()}`
    ].filter(Boolean).join(" ");
    if (options.baseUrl) {
      requestDefaults.baseUrl = options.baseUrl;
    }
    if (options.previews) {
      requestDefaults.mediaType.previews = options.previews;
    }
    if (options.timeZone) {
      requestDefaults.headers["time-zone"] = options.timeZone;
    }
    this.request = request.defaults(requestDefaults);
    this.graphql = withCustomRequest(this.request).defaults(requestDefaults);
    this.log = Object.assign({
      debug: () => {
      },
      info: () => {
      },
      warn: console.warn.bind(console),
      error: console.error.bind(console)
    }, options.log);
    this.hook = hook2;
    if (!options.authStrategy) {
      if (!options.auth) {
        this.auth = () => __async(this, null, function* () {
          return {
            type: "unauthenticated"
          };
        });
      } else {
        const auth2 = createTokenAuth(options.auth);
        hook2.wrap("request", auth2.hook);
        this.auth = auth2;
      }
    } else {
      const _a = options, { authStrategy } = _a, otherOptions = __objRest(_a, ["authStrategy"]);
      const auth2 = authStrategy(Object.assign({
        request: this.request,
        log: this.log,
        octokit: this,
        octokitOptions: otherOptions
      }, options.auth));
      hook2.wrap("request", auth2.hook);
      this.auth = auth2;
    }
    const classConstructor = this.constructor;
    classConstructor.plugins.forEach((plugin) => {
      Object.assign(this, plugin(this, options));
    });
  }
  static defaults(defaults) {
    const OctokitWithDefaults = class extends this {
      constructor(...args) {
        const options = args[0] || {};
        if (typeof defaults === "function") {
          super(defaults(options));
          return;
        }
        super(Object.assign({}, defaults, options, options.userAgent && defaults.userAgent ? {
          userAgent: `${options.userAgent} ${defaults.userAgent}`
        } : null));
      }
    };
    return OctokitWithDefaults;
  }
  static plugin(...newPlugins) {
    var _a;
    const currentPlugins = this.plugins;
    const NewOctokit = (_a = class extends this {
    }, _a.plugins = currentPlugins.concat(newPlugins.filter((plugin) => !currentPlugins.includes(plugin))), _a);
    return NewOctokit;
  }
};
Octokit.VERSION = VERSION4;
Octokit.plugins = [];

// node_modules/js-base64/base64.mjs
var version = "3.7.2";
var VERSION5 = version;
var _hasatob = typeof atob === "function";
var _hasbtoa = typeof btoa === "function";
var _hasBuffer = typeof Buffer === "function";
var _TD = typeof TextDecoder === "function" ? new TextDecoder() : void 0;
var _TE = typeof TextEncoder === "function" ? new TextEncoder() : void 0;
var b64ch = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
var b64chs = Array.prototype.slice.call(b64ch);
var b64tab = ((a) => {
  let tab = {};
  a.forEach((c, i) => tab[c] = i);
  return tab;
})(b64chs);
var b64re = /^(?:[A-Za-z\d+\/]{4})*?(?:[A-Za-z\d+\/]{2}(?:==)?|[A-Za-z\d+\/]{3}=?)?$/;
var _fromCC = String.fromCharCode.bind(String);
var _U8Afrom = typeof Uint8Array.from === "function" ? Uint8Array.from.bind(Uint8Array) : (it, fn = (x) => x) => new Uint8Array(Array.prototype.slice.call(it, 0).map(fn));
var _mkUriSafe = (src) => src.replace(/=/g, "").replace(/[+\/]/g, (m0) => m0 == "+" ? "-" : "_");
var _tidyB64 = (s) => s.replace(/[^A-Za-z0-9\+\/]/g, "");
var btoaPolyfill = (bin) => {
  let u32, c0, c1, c2, asc = "";
  const pad = bin.length % 3;
  for (let i = 0; i < bin.length; ) {
    if ((c0 = bin.charCodeAt(i++)) > 255 || (c1 = bin.charCodeAt(i++)) > 255 || (c2 = bin.charCodeAt(i++)) > 255)
      throw new TypeError("invalid character found");
    u32 = c0 << 16 | c1 << 8 | c2;
    asc += b64chs[u32 >> 18 & 63] + b64chs[u32 >> 12 & 63] + b64chs[u32 >> 6 & 63] + b64chs[u32 & 63];
  }
  return pad ? asc.slice(0, pad - 3) + "===".substring(pad) : asc;
};
var _btoa = _hasbtoa ? (bin) => btoa(bin) : _hasBuffer ? (bin) => Buffer.from(bin, "binary").toString("base64") : btoaPolyfill;
var _fromUint8Array = _hasBuffer ? (u8a) => Buffer.from(u8a).toString("base64") : (u8a) => {
  const maxargs = 4096;
  let strs = [];
  for (let i = 0, l = u8a.length; i < l; i += maxargs) {
    strs.push(_fromCC.apply(null, u8a.subarray(i, i + maxargs)));
  }
  return _btoa(strs.join(""));
};
var fromUint8Array = (u8a, urlsafe = false) => urlsafe ? _mkUriSafe(_fromUint8Array(u8a)) : _fromUint8Array(u8a);
var cb_utob = (c) => {
  if (c.length < 2) {
    var cc = c.charCodeAt(0);
    return cc < 128 ? c : cc < 2048 ? _fromCC(192 | cc >>> 6) + _fromCC(128 | cc & 63) : _fromCC(224 | cc >>> 12 & 15) + _fromCC(128 | cc >>> 6 & 63) + _fromCC(128 | cc & 63);
  } else {
    var cc = 65536 + (c.charCodeAt(0) - 55296) * 1024 + (c.charCodeAt(1) - 56320);
    return _fromCC(240 | cc >>> 18 & 7) + _fromCC(128 | cc >>> 12 & 63) + _fromCC(128 | cc >>> 6 & 63) + _fromCC(128 | cc & 63);
  }
};
var re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g;
var utob = (u) => u.replace(re_utob, cb_utob);
var _encode = _hasBuffer ? (s) => Buffer.from(s, "utf8").toString("base64") : _TE ? (s) => _fromUint8Array(_TE.encode(s)) : (s) => _btoa(utob(s));
var encode = (src, urlsafe = false) => urlsafe ? _mkUriSafe(_encode(src)) : _encode(src);
var encodeURI2 = (src) => encode(src, true);
var re_btou = /[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g;
var cb_btou = (cccc) => {
  switch (cccc.length) {
    case 4:
      var cp = (7 & cccc.charCodeAt(0)) << 18 | (63 & cccc.charCodeAt(1)) << 12 | (63 & cccc.charCodeAt(2)) << 6 | 63 & cccc.charCodeAt(3), offset = cp - 65536;
      return _fromCC((offset >>> 10) + 55296) + _fromCC((offset & 1023) + 56320);
    case 3:
      return _fromCC((15 & cccc.charCodeAt(0)) << 12 | (63 & cccc.charCodeAt(1)) << 6 | 63 & cccc.charCodeAt(2));
    default:
      return _fromCC((31 & cccc.charCodeAt(0)) << 6 | 63 & cccc.charCodeAt(1));
  }
};
var btou = (b) => b.replace(re_btou, cb_btou);
var atobPolyfill = (asc) => {
  asc = asc.replace(/\s+/g, "");
  if (!b64re.test(asc))
    throw new TypeError("malformed base64.");
  asc += "==".slice(2 - (asc.length & 3));
  let u24, bin = "", r1, r2;
  for (let i = 0; i < asc.length; ) {
    u24 = b64tab[asc.charAt(i++)] << 18 | b64tab[asc.charAt(i++)] << 12 | (r1 = b64tab[asc.charAt(i++)]) << 6 | (r2 = b64tab[asc.charAt(i++)]);
    bin += r1 === 64 ? _fromCC(u24 >> 16 & 255) : r2 === 64 ? _fromCC(u24 >> 16 & 255, u24 >> 8 & 255) : _fromCC(u24 >> 16 & 255, u24 >> 8 & 255, u24 & 255);
  }
  return bin;
};
var _atob = _hasatob ? (asc) => atob(_tidyB64(asc)) : _hasBuffer ? (asc) => Buffer.from(asc, "base64").toString("binary") : atobPolyfill;
var _toUint8Array = _hasBuffer ? (a) => _U8Afrom(Buffer.from(a, "base64")) : (a) => _U8Afrom(_atob(a), (c) => c.charCodeAt(0));
var toUint8Array = (a) => _toUint8Array(_unURI(a));
var _decode = _hasBuffer ? (a) => Buffer.from(a, "base64").toString("utf8") : _TD ? (a) => _TD.decode(_toUint8Array(a)) : (a) => btou(_atob(a));
var _unURI = (a) => _tidyB64(a.replace(/[-_]/g, (m0) => m0 == "-" ? "+" : "/"));
var decode = (src) => _decode(_unURI(src));
var isValid = (src) => {
  if (typeof src !== "string")
    return false;
  const s = src.replace(/\s+/g, "").replace(/={0,2}$/, "");
  return !/[^\s0-9a-zA-Z\+/]/.test(s) || !/[^\s0-9a-zA-Z\-_]/.test(s);
};
var _noEnum = (v) => {
  return {
    value: v,
    enumerable: false,
    writable: true,
    configurable: true
  };
};
var extendString = function() {
  const _add = (name, body) => Object.defineProperty(String.prototype, name, _noEnum(body));
  _add("fromBase64", function() {
    return decode(this);
  });
  _add("toBase64", function(urlsafe) {
    return encode(this, urlsafe);
  });
  _add("toBase64URI", function() {
    return encode(this, true);
  });
  _add("toBase64URL", function() {
    return encode(this, true);
  });
  _add("toUint8Array", function() {
    return toUint8Array(this);
  });
};
var extendUint8Array = function() {
  const _add = (name, body) => Object.defineProperty(Uint8Array.prototype, name, _noEnum(body));
  _add("toBase64", function(urlsafe) {
    return fromUint8Array(this, urlsafe);
  });
  _add("toBase64URI", function() {
    return fromUint8Array(this, true);
  });
  _add("toBase64URL", function() {
    return fromUint8Array(this, true);
  });
};
var extendBuiltins = () => {
  extendString();
  extendUint8Array();
};
var gBase64 = {
  version,
  VERSION: VERSION5,
  atob: _atob,
  atobPolyfill,
  btoa: _btoa,
  btoaPolyfill,
  fromBase64: decode,
  toBase64: encode,
  encode,
  encodeURI: encodeURI2,
  encodeURL: encodeURI2,
  utob,
  btou,
  decode,
  isValid,
  fromUint8Array,
  toUint8Array,
  extendString,
  extendUint8Array,
  extendBuiltins
};

// Snippet-downloader/downloader.ts
var import_obsidian3 = __toModule(require("obsidian"));
function fetchListSnippet(repoRecur, snippetList, settings, repoPath) {
  return __async(this, null, function* () {
    for (const data of repoRecur.data.tree) {
      if (data.path.endsWith(".css") && !searchExcluded(settings.excludedSnippet, data.path) && data.path != "obsidian.css" && !searchExcluded(settings.errorSnippet, data.path)) {
        const snippetName = data.path;
        const snippetLastUpdate = yield grabLastCommitDate(repoPath, data.path);
        snippetList.push({
          name: snippetName,
          lastUpdate: snippetLastUpdate
        });
      }
    }
    return snippetList;
  });
}
function grabLastCommitInfo(repoPath, filepath) {
  return __async(this, null, function* () {
    const repoName = repoPath.replace("https://github.com/", "");
    const url = `https://api.github.com/repos/${repoName}/commits?path=${encodeURIComponent(filepath)}&page=1&per_page=1`;
    try {
      const response = yield (0, import_obsidian3.request)({ url });
      return response === "404: Not Found" ? null : JSON.parse(response);
    } catch (error) {
      console.log("error in grabcommitinfo", error);
    }
  });
}
function grabLastCommitDate(repoPath, filepath) {
  return __async(this, null, function* () {
    const test = yield grabLastCommitInfo(repoPath, filepath);
    console.log(`Testing from ${repoPath} : ${filepath} => ${test[0].commit.author.date}`);
    if (test[0].commit.author.date) {
      return test[0].commit.author.date;
    } else {
      return "";
    }
  });
}
function listSnippetfromRepo(repoPath, settings) {
  return __async(this, null, function* () {
    const octokit = new Octokit();
    const repo = repoPath.replace("https://github.com/", "");
    const owner = repo.split("/")[0];
    const repoName = repo.split("/")[1];
    console.log(`Repo: ${repoPath}, owner: ${owner}, repoName: ${repoName}`);
    const snippetList = [];
    try {
      const repoRecur = yield octokit.request("GET /repos/{owner}/{repo}/git/trees/{tree_sha}", {
        owner,
        repo: repoName,
        tree_sha: "main",
        recursive: "true"
      });
      return yield fetchListSnippet(repoRecur, snippetList, settings, repoPath);
    } catch (e) {
      try {
        const repoRecur = yield octokit.request("GET /repos/{owner}/{repo}/git/trees/{tree_sha}", {
          owner,
          repo: repoName,
          tree_sha: "main",
          recursive: "true"
        });
        return yield fetchListSnippet(repoRecur, snippetList, settings, repoPath);
      } catch (e2) {
        console.log(e2);
        return [];
      }
    }
  });
}
function checkLastUpdate(snippetName, repoPath) {
  return __async(this, null, function* () {
    const oldDate = new Date(snippetName.lastUpdate);
    const newDate = new Date(yield grabLastCommitDate(repoPath, snippetName.name));
    return oldDate < newDate;
  });
}
function downloadSnippet(repoPath, snippetName, vault) {
  return __async(this, null, function* () {
    const repo = repoPath.replace("https://github.com/", "");
    const owner = repo.split("/")[0];
    const repoName = repo.split("/")[1];
    const octokit = new Octokit();
    const fileName = basename(snippetName);
    const filePath = (0, import_obsidian3.normalizePath)(vault.configDir + "/snippets/" + fileName);
    try {
      const file = yield octokit.request("GET /repos/{owner}/{repo}/contents/{path}", {
        owner,
        repo: repoName,
        path: snippetName
      });
      console.log(file.status);
      if (file.status === 200) {
        const fileContent = gBase64.decode(file.data.content);
        const adapter = vault.adapter;
        yield adapter.write(filePath, fileContent);
        return true;
      } else {
        return false;
      }
    } catch (e) {
      console.log(e);
    }
  });
}

// Snippet-downloader/addSnippets.ts
function addSnippet(repoPath, settings, vault) {
  return __async(this, null, function* () {
    const snippetList = settings.snippetList;
    let excludedSnippet = settings.errorSnippet;
    const catchErrors = [];
    if (!snippetList.some((snippet) => snippet.repo === repoPath)) {
      const newSnippetList = yield listSnippetfromRepo(repoPath, settings);
      if (newSnippetList.length === 0) {
        new import_obsidian4.Notice("Error \u{1F63F}, snippet or repository not found");
        return snippetList;
      }
      snippetList.push({
        repo: repoPath,
        snippetsContents: yield listSnippetfromRepo(repoPath, settings)
      });
      const snippet = snippetList.find((snippet2) => snippet2.repo === repoPath);
      for (const snippetContents of snippet.snippetsContents) {
        const success = yield downloadSnippet(repoPath, snippetContents.name, vault);
        if (!success) {
          excludedSnippet += snippetContents.name.replace(".css", "") + ", ";
          catchErrors.push(snippetContents.name.replace(".css", ""));
        }
      }
      let messageNotice = `Successfully added ${repoPath}. ${newSnippetList.length} snippets added. \u{1F389}`;
      if (catchErrors.length > 0) {
        messageNotice += `
${catchErrors.length} snippets not added\u{1F63F}: ${catchErrors.join(", ")}`;
      }
      new import_obsidian4.Notice(messageNotice);
      return [snippetList, excludedSnippet];
    }
    new import_obsidian4.Notice("Error : this repo is already in the list \u{1F63F}");
    return [snippetList, excludedSnippet];
  });
}
function updateRepo(repoPath, snippetList, vault, excludedSnippets, errorSnippets) {
  return __async(this, null, function* () {
    const snippet = snippetList.find((snippet2) => snippet2.repo === repoPath);
    if (snippet) {
      for (const snippetContent of snippet.snippetsContents) {
        if ((yield checkLastUpdate(snippetContent, repoPath)) && snippetContent.name !== "obsidian.css" && !searchExcluded(excludedSnippets, snippetContent.name) && !searchExcluded(errorSnippets, snippetContent.name)) {
          const successDownloaded = yield downloadSnippet(repoPath, snippetContent.name, vault);
          if (successDownloaded) {
            snippetContent.lastUpdate = yield grabLastCommitDate(repoPath, snippetContent.name);
          } else {
            errorSnippets += snippetContent.name.replace(".css", "") + ", ";
          }
        }
      }
    }
    snippetList = removeSnippetFromExcluded(repoPath, snippetList, errorSnippets, excludedSnippets);
    new import_obsidian4.Notice(`${repoPath} successfully updated \u{1F389}`);
    return [snippetList, errorSnippets];
  });
}
function updateSpecificSnippet(item, settings) {
  return __async(this, null, function* () {
    let listSnippet = settings.snippetList;
    let excludedSnippet = settings.errorSnippet;
    const snippet = listSnippet.find((snippet2) => snippet2.repo === item.repo);
    const snippetsRep = snippet.snippetsContents.find((snippet2) => snippet2.name === item.snippetPath);
    if (yield checkLastUpdate(snippetsRep, item.repo)) {
      const successDownload = yield downloadSnippet(item.repo, snippetsRep.name, this.app.vault);
      if (successDownload) {
        snippetsRep.lastUpdate = yield grabLastCommitDate(item.repo, snippetsRep.name);
        new import_obsidian4.Notice(`${basename(item.snippetPath)} has been updated \u{1F389}`);
        return [
          listSnippet,
          excludedSnippet
        ];
      } else {
        excludedSnippet = excludedSnippet + item.snippetPath.replace(".css", "") + ", ";
        listSnippet = removeSnippetFromExcluded(item.repo, listSnippet, excludedSnippet, settings.excludedSnippet);
        return [
          listSnippet,
          excludedSnippet
        ];
      }
    }
    listSnippet = removeSnippetFromExcluded(item.repo, listSnippet, excludedSnippet, settings.excludedSnippet);
    new import_obsidian4.Notice(`${basename(item.snippetPath)} is already up to date \u{1F4A1}`);
    return [
      listSnippet,
      excludedSnippet
    ];
  });
}

// Snippet-downloader/modals/updateSnippets.ts
var import_obsidian5 = __toModule(require("obsidian"));
function getAllRepo(settings) {
  const repoAll = [];
  for (const repo of settings.snippetList) {
    repoAll.push({
      repoName: repo.repo,
      repoUrl: ""
    });
  }
  return repoAll;
}
function getAllSnippet(settings) {
  const allSnippet = [];
  for (const snippet of settings.snippetList) {
    for (const snippetContent of snippet.snippetsContents) {
      if (snippetContent.name !== "obsidian.css" && !searchExcluded(settings.excludedSnippet, snippetContent.name) && !searchExcluded(settings.errorSnippet, snippetContent.name)) {
        allSnippet.push({
          repo: snippet.repo,
          snippetPath: snippetContent.name
        });
      }
    }
  }
  return allSnippet;
}
var RepoDownloader = class extends import_obsidian5.FuzzySuggestModal {
  constructor(app, settings, plugin) {
    super(app);
    this.settings = settings;
    this.plugin = plugin;
  }
  getItemText(item) {
    return item.repoName;
  }
  getItems() {
    return getAllRepo(this.settings);
  }
  onChooseItem(item, evt) {
    return __async(this, null, function* () {
      const allSettings = yield updateRepo(item.repoName, this.settings.snippetList, this.app.vault, this.settings.excludedSnippet, this.settings.errorSnippet);
      yield this.plugin.updateList(allSettings);
    });
  }
};
var SpecificSnippetDownloader = class extends import_obsidian5.FuzzySuggestModal {
  constructor(app, settings, plugin) {
    super(app);
    this.settings = settings;
    this.plugin = plugin;
  }
  getItemText(item) {
    return basename(item.snippetPath);
  }
  getItems() {
    return getAllSnippet(this.settings);
  }
  onChooseItem(item, evt) {
    return __async(this, null, function* () {
      const newList = yield updateSpecificSnippet(item, this.settings);
      yield this.plugin.updateList(newList);
    });
  }
};

// Snippet-downloader/modals/excludeSnippet.ts
var import_obsidian6 = __toModule(require("obsidian"));
function getExcludedSnippets(settings) {
  const allSnippet = [];
  for (const snippet of settings.snippetList) {
    for (const snippetContent of snippet.snippetsContents) {
      if (snippetContent.name !== "obsidian.css" && !searchExcluded(settings.excludedSnippet, snippetContent.name) && !searchExcluded(settings.errorSnippet, snippetContent.name)) {
        allSnippet.push({
          repo: snippet.repo,
          snippetPath: snippetContent.name
        });
      }
    }
  }
  return allSnippet;
}
function addExcludedSnippet(item, settings) {
  return __async(this, null, function* () {
    let excludedSnippet = settings.excludedSnippet;
    excludedSnippet = excludedSnippet + ", " + item.snippetPath;
    const snippetList = removeSnippetFromExcluded(item.repo, settings.snippetList, settings.errorSnippet, excludedSnippet);
    return [snippetList, excludedSnippet];
  });
}
var ExcludeSnippet = class extends import_obsidian6.FuzzySuggestModal {
  constructor(app, settings, plugin) {
    super(app);
    this.settings = settings;
    this.plugin = plugin;
  }
  getItemText(item) {
    return basename(item.snippetPath);
  }
  getItems() {
    return getExcludedSnippets(this.settings);
  }
  onChooseItem(item, evt) {
    return __async(this, null, function* () {
      const newSettings = yield addExcludedSnippet(item, this.settings);
      yield this.plugin.updateList(newSettings);
      new import_obsidian6.Notice(`${basename(item.snippetPath)} has been excluded! \u{1F389}`);
    });
  }
};

// Snippet-downloader/settings.ts
var DEFAULT_SETTINGS = {
  snippetList: [],
  excludedSnippet: "",
  errorSnippet: ""
};
function getDetailsState(name) {
  for (let i = 0; i < document.getElementsByTagName("details").length; i++) {
    const details = document.getElementsByTagName("details")[i];
    if (details.innerText.split("\n")[0] === name) {
      return details.hasAttribute("open");
    }
  }
  return true;
}
function openDetails(name, detailsState) {
  const allDetails = document.getElementsByTagName("details");
  for (let i = 0; i < allDetails.length; i++) {
    const details = allDetails[i];
    if (details.innerText.split("\n")[0] === name && detailsState) {
      details.setAttr("open", "true");
      details.open = true;
      details.setAttribute("open", "true");
    } else if (details.innerText.split("\n")[0] === name && !detailsState) {
      details.removeAttribute("open");
      details.setAttribute("open", "false");
    }
  }
}
var SnippetDownloaderTabs = class extends import_obsidian7.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    const allSnippets = getAllSnippet(this.plugin.settings);
    containerEl.createEl("h2", { text: "Snippet Manager Settings" });
    const desc_excluder = document.createDocumentFragment();
    desc_excluder.createEl("span", null, (span) => {
      span.innerText = "Type the snippet name you want to exclude from the list, without the extension.\nYou can also use regex, for example: ";
      span.createEl("code", { text: "^(.*)$" });
      span.createEl("span", { text: " will match all snippets.\n\n" });
      span.createEl("a", null, (link) => {
        link.innerText = "You can check your regex here.";
        link.href = "https://regex101.com/";
      });
    });
    new import_obsidian7.Setting(containerEl).setName("Excluded Snippet").setDesc(desc_excluder).addTextArea((text) => text.setPlaceholder("BadCSS I hate, badCSS*").setValue(this.plugin.settings.excludedSnippet).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.excludedSnippet = value;
      yield this.plugin.saveSettings();
    })));
    const desc_plugins = document.createDocumentFragment();
    desc_plugins.createEl("span", {
      text: `The following is a list of the repository added via the command palette `
    });
    desc_plugins.createEl("div", {
      text: `Click the x button next to a repository to remove it from the list.`
    });
    desc_plugins.createEl("b", { text: "Note: " });
    desc_plugins.createEl("span", { text: "This does not delete the linked snippet, this should be done from your " });
    desc_plugins.createEl("code", { text: ".obsidian/snippets" }).setAttribute("style", "font-family: var(--font-monospace)");
    desc_plugins.createEl("span", { text: " folder" });
    new import_obsidian7.Setting(containerEl).setName("Repository Snippet List").setDesc(desc_plugins).addButton((btn) => {
      btn.setIcon("plus").setTooltip("Add new repository").onClick(() => __async(this, null, function* () {
        new SnippetDownloaderModals(this.app, (result) => __async(this, null, function* () {
          if (result) {
            const newSettings = yield addSnippet(result.trim(), this.plugin.settings, this.app.vault);
            yield this.plugin.updateList(newSettings);
            const detailState = getDetailsState(result);
            this.display();
            openDetails(result, detailState);
          }
        })).open();
      }));
    }).addButton((btn) => {
      btn.setIcon("install").setTooltip("Update all repository").onClick(() => __async(this, null, function* () {
        this.plugin.updateAllSnippets();
      }));
    });
    for (const repoPath of this.plugin.settings.snippetList) {
      const details = containerEl.createEl("details");
      const repoName = repoPath.repo.replace("https://github.com/", "");
      const summary = details.createEl("summary", { text: repoName });
      summary.addClass("snippets-downloader-summary");
      new import_obsidian7.Setting(summary).setClass("snippets-downloader-options").addButton((btn) => {
        btn.setClass("snippets-downloader-options-button").setIcon("cross").setTooltip("Delete this repository from the list").onClick(() => __async(this, null, function* () {
          btn.buttonEl.parentElement.remove();
          const newSettings = removeSnippet(repoPath.repo, this.plugin.settings.snippetList, this.plugin.settings.errorSnippet);
          yield this.plugin.updateList(newSettings);
          const detailState = getDetailsState(repoName);
          this.display();
          openDetails(repoName, detailState);
        }));
      }).addButton((btn) => {
        btn.setClass("snippets-downloader-options-button").setIcon("sync").setTooltip("Update this repository").onClick(() => __async(this, null, function* () {
          const allSettings = yield updateRepo(repoPath.repo, this.plugin.settings.snippetList, this.app.vault, this.plugin.settings.excludedSnippet, this.plugin.settings.errorSnippet);
          yield this.plugin.updateList(allSettings);
        }));
      });
      for (const snippets of repoPath.snippetsContents) {
        new import_obsidian7.Setting(details).setName(basename(snippets.name)).setClass("snippets-downloader-settings").addExtraButton((btn) => {
          btn.setTooltip("Update this snippet").setIcon("install").onClick(() => __async(this, null, function* () {
            const updatedList = yield updateSpecificSnippet(allSnippets.find((s) => snippets.name === s.snippetPath), this.plugin.settings);
            yield this.plugin.updateList(updatedList);
          }));
        }).addExtraButton((btn) => {
          btn.setTooltip("Remove this snippet").setIcon("trash").onClick(() => __async(this, null, function* () {
            btn.extraSettingsEl.parentElement.parentElement.remove();
            const updatedList = yield addExcludedSnippet(getExcludedSnippets(this.plugin.settings).find((s) => snippets.name === s.snippetPath), this.plugin.settings);
            yield this.plugin.updateList(updatedList);
          }));
        });
      }
    }
  }
};

// Snippet-downloader/main.ts
var snippetDownloader = class extends import_obsidian8.Plugin {
  updateAllSnippets() {
    return __async(this, null, function* () {
      if (this.settings.snippetList.length > 0) {
        const snippetList = this.settings.snippetList;
        const errorSnippet = this.settings.errorSnippet;
        const excludedSnippet = this.settings.excludedSnippet;
        let updatedSettings = [errorSnippet, snippetList];
        for (const repoName of snippetList) {
          updatedSettings = yield updateRepo(repoName.repo, snippetList, this.app.vault, excludedSnippet, errorSnippet);
          this.settings.snippetList = updatedSettings[1];
          this.settings.errorSnippet = updatedSettings[0];
        }
        yield this.saveSettings();
      }
    });
  }
  updateList(newSettings) {
    return __async(this, null, function* () {
      this.settings.snippetList = newSettings[0];
      this.settings.errorSnippet = newSettings[1];
      yield this.saveSettings();
    });
  }
  onload() {
    return __async(this, null, function* () {
      yield this.loadSettings();
      this.addCommand({
        id: "add-snippet",
        name: "Adding new snippet",
        callback: () => {
          new SnippetDownloaderModals(this.app, (result) => __async(this, null, function* () {
            if (result) {
              const newSettings = yield addSnippet(result.trim(), this.settings, this.app.vault);
              yield this.updateList(newSettings);
            }
          })).open();
        }
      });
      this.addCommand({
        id: "update-all-snippets",
        name: "Update all snippets",
        checkCallback: (checking) => __async(this, null, function* () {
          if (this.settings.snippetList.length > 0) {
            if (!checking) {
              const snippetList = this.settings.snippetList;
              const errorSnippet = this.settings.errorSnippet;
              const excludedSnippet = this.settings.excludedSnippet;
              let updatedSettings = [errorSnippet, snippetList];
              for (const repoName of snippetList) {
                updatedSettings = yield updateRepo(repoName.repo, snippetList, this.app.vault, excludedSnippet, errorSnippet);
                yield this.updateList(updatedSettings);
              }
              yield this.saveSettings();
            }
            return true;
          }
          return false;
        })
      });
      this.addCommand({
        id: "update-specific-repo",
        name: "Update specific repository",
        hotkeys: [],
        checkCallback: (checking) => {
          if (this.settings.snippetList.length > 0) {
            if (!checking) {
              new RepoDownloader(this.app, this.settings, this).open();
            }
            return true;
          }
          return false;
        }
      });
      this.addCommand({
        id: "update-specific-snippet",
        name: "Update specific snippet",
        hotkeys: [],
        checkCallback: (checking) => {
          if (this.settings.snippetList.length > 0) {
            if (!checking) {
              new SpecificSnippetDownloader(this.app, this.settings, this).open();
            }
            return true;
          }
          return false;
        }
      });
      this.addCommand({
        id: "remove-specific-snippet",
        name: "Exclude specific snippet",
        hotkeys: [],
        checkCallback: (checking) => {
          if (this.settings.snippetList.length > 0) {
            if (!checking) {
              new ExcludeSnippet(this.app, this.settings, this).open();
            }
            return true;
          }
          return false;
        }
      });
      this.addSettingTab(new SnippetDownloaderTabs(this.app, this));
    });
  }
  onunload() {
  }
  loadSettings() {
    return __async(this, null, function* () {
      this.settings = Object.assign({}, DEFAULT_SETTINGS, yield this.loadData());
    });
  }
  saveSettings() {
    return __async(this, null, function* () {
      yield this.saveData(this.settings);
    });
  }
};
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
